%
% 6.006 problem set 1 solutions template
%
\documentclass[12pt,twoside]{article}

\usepackage{amsmath}
\usepackage{color}

\input{macros}

\setlength{\oddsidemargin}{0pt}
\setlength{\evensidemargin}{0pt}
\setlength{\textwidth}{6.5in}
\setlength{\topmargin}{0in}
\setlength{\textheight}{8.5in}

\newcommand{\theproblemsetnum}{1}
\newcommand{\releasedate}{Tuesday, September 13}
\newcommand{\partaduedate}{Tuesday, September 27}
\newcommand{\tabUnit}{3ex}
\newcommand{\myname}{Milo H. Knowles}

%define collaborators here
\newcommand{\collabs}{Gillian Belton, Magnus Johnson, Kacie Bawiec}

\newcommand{\tabT}{\hspace*{\tabUnit}}

\title{6.006 Problem Set 1}

%everything after the begin command is in the document
\begin{document}

\handout{Problem Set \theproblemsetnum}{September 13, 2016}

\textbf{All parts are due {\bf \partaduedate} at {\bf 11:59PM}}.
\textbf{asfjsdlkfjkldsjf}

\setlength{\parindent}{0pt}

\medskip

\hrulefill

\medskip

{\bf Name:} \myname

\medskip

{\bf Collaborators:} \collabs

\medskip

\hrulefill

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% See below for common and useful latex constructs. %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Some useful commands:
%$f(x) = \Theta(x)$
%$T(x, y) \leq \log(x) + 2^y + \binom{2n}{n}$
% {\tt code\_function}


% You can create unnumbered lists as follows:
%\begin{itemize}
%    \item First item in a list 
%        \begin{itemize}
%            \item First item in a list 
%                \begin{itemize}
%                    \item First item in a list 
%                    \item Second item in a list 
%                \end{itemize}
%            \item Second item in a list 
%        \end{itemize}
%    \item Second item in a list 
%\end{itemize}

% You can create numbered lists as follows:
%\begin{enumerate}
%    \item First item in a list 
%    \item Second item in a list 
%    \item Third item in a list
%\end{enumerate}

% You can write aligned equations as follows:
%\begin{align} 
%    \begin{split}
%        (x+y)^3 &= (x+y)^2(x+y) \\
%                &= (x^2+2xy+y^2)(x+y) \\
%                &= (x^3+2x^2y+xy^2) + (x^2y+2xy^2+y^3) \\
%                &= x^3+3x^2y+3xy^2+y^3
%    \end{split}                                 
%\end{align}

% You can create grids/matrices as follows:
%\begin{align}
%    A = 
%    \begin{bmatrix}
%        A_{11} & A_{21} \\
%        A_{21} & A_{22}
%    \end{bmatrix}
%\end{align}

\begin{problems}

%star after section means that the section is not NUMBERED
\section*{Part A}

\problem  % Problem 1

\begin{problemparts}
\problempart Part a  % Problem 1a
\problempart Part b  % Problem 1b
\problempart Part c  % Problem 1c
\end{problemparts}

\problem  % Problem 2

\begin{problemparts}
\problempart Part a % Problem 2a
\problempart Part b % Problem 2b
\end{problemparts}

\problem  % Problem 3

\begin{problemparts}
\problempart Part a % Problem 3a
\problempart Part b % Problem 3b
\end{problemparts}

\section*{Part B}

\problem
\begin{problemparts}
\problempart \emph{Submit your implementation on alg.csail.mit.edu}
\problempart \emph{Submit your implementation on alg.csail.mit.edu}
\problempart \emph{Submit your implementation on alg.csail.mit.edu}
\problempart Part d % Problem 4d

Below is a list of the constants used in runtime analysis for parts (b) and (c):
\begin{itemize}
	\item $n$, the total number of articles
	\item $m$, the total number of words in each article (assumed to be the same for every article)
	\item $k$, the number of relevant articles to return
	\item $q$, the number of distinct terms in the query (for part (c))
	\item $w$, the number of unique words in the corpus (no repeats)
\end{itemize}

%make a list of the steps in part(b) with their runtime expressions

\newcommand{\functionb}{get-relevant-articles-tf-idf}


The implementation of {\bf \functionb} from {\bf part(b)} is outlined below:
\begin{enumerate}
	\item For each article, build a term-frequency dictionary. This takes $\theta(nm)$ time, because the code iterates over exactly $n$ articles, and $m$ words in each article.
	\item Next, the function builds a document-frequency dictionary, storing each word in the corpus as a key, and the number of articles that contain that word as a value. This takes $\theta(nm)$ time, because the code iterates over $n$ articles, and $m$ words in each article.
	\item For each {\textit unique} term in the corpus, the inverse-document-frequency is computed and added to a new {\bf corpusIDFDict} dictionary. This takes $\theta(w)$ time, because the code only considers unique words, without repeats.
	\item For each article in the corpus an angle is computed between that article and the query article. $\theta(n-1)$ comparisons must be done, because the query article is not compared to itself. The helper function {\bf computeAngleBetweenWFIDFDicts} is used to compute the angle between two WFIDF dictionaries. It runs in $\theta(5m)$ time.
		\begin{itemize}
			\item The helper function {\bf computeAngleBetweenWFIDFDicts} is used to compute the angle between two WFIDF dictionaries. It runs in $\theta(5m)$ time.
			\item $\theta(m)$ to convert one term-frequency dictionary to a TFIDF dictionary.
			\item $\theta(m)$ to convert the other term-frequency dictionary to a TFIDF dictionary.
			\item $\theta(m)$ to compute the dot product of the two TFIDF dictionary values.
			\item $\theta(m)$ to compute the magnitude of one TFIDF dictionary.
			\item $\theta(m)$ to compute the magnitude of the other TFIDF dictionary.
		\end{itemize}
	\item The angle between every article and the query article is stored in a list. There are $n-1$ elements in the list, so it will take $O(n \cdot log_2n)$ time to sort this list.
	\item To return the $k$ closest articles from the sorted list, it will take $\theta(k)$ time.
\end{enumerate}





\problempart Part e % Problem 4e
\end{problemparts}

\end{problems}

\end{document}

